# Compute the reciprocity for each sample
# generated by the sampler given in input
import sys
sys.path.insert(1, '../')
from helpers.hyprec.HyperRec import measure_reciprocity, parallel_reciprocity
from helpers.config import sample_path, met_path, max_workers, alpha, folder
from helpers.io import read_as_directed_hyperedge_list
import numpy as np
import zipfile
from tqdm.contrib.concurrent import process_map
from collections import defaultdict


if __name__ == "__main__":
    root = sys.argv[1]
    typ = sys.argv[2]
    data_path = folder + root
    print(root, typ)

    # READ ORIGINAL
    vmap = defaultdict(int)
    with open(f'{data_path}.tsv') as in_f:
        heads, tails = read_as_directed_hyperedge_list(in_f, vmap)
    head_index = np.array([set(t) for t in heads])
    tail_index = np.array([set(t) for t in tails])

    num_vertices = len(vmap)

    max_m = max([len(heads[i]) + len(tails[i]) for i in range(len(tails))]) + 1
    max_m = min(max_m, 10)

    # RECIPROCITY
    print('starting computation of reciprocity.')
    # reciprocity in original dataset
    recip_vec = measure_reciprocity(head_index,
                                    tail_index,
                                    alpha=alpha,
                                    special_case="normal")
    out_f = open(met_path + f"reciprocity_{root}.tsv", 'w')
    out_f.write('Reciprocity\tHyperEdge Id\n')
    for idx, r in enumerate(recip_vec):
        out_f.write(f'{r}\t{idx}\n')
    out_f.close()
    print('reciprocity original dataset computed.')

    file_path = f'{sample_path}/{typ}/{root}.zip'
    out_f = open(met_path + f"reciprocity_{root}_samples_{typ}.tsv", 'w')
    out_f.write('Sampler\tSample Id\tReciprocity\tHyperEdge Id\n')

    z = zipfile.ZipFile(file_path, "r")
    zinfo = z.namelist()
    inputs = []
    for file_name in zinfo:
        if file_name.startswith(".") or file_name.startswith("__MACOSX"):
            continue
        if not file_name.endswith('.tsv'):
            continue
        inputs.append([file_path, file_name, vmap, typ])
    outputs = process_map(parallel_reciprocity,
                          inputs,
                          max_workers=max_workers)
    for lst in outputs:
        for s in lst:
            out_f.write('\t'.join(s) + '\n')
    out_f.close()
    print('reciprocity computed.')
