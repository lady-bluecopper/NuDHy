# Generates the multi-order Laplacian of an undirected hypergraph,
# finds its eigenvalues, and computes the spectral distance
# between the observed eigenvalues and the eigenvalues in the samples
# generated by the sampler given in input
import sys
sys.path.insert(1, '../')
from helpers.config import order, eig_num, symmetric, max_workers, toll
from helpers.config import sample_path, met_path, folder
from helpers.laplacian import parallel_laplacian, compute_eigenvalues
from helpers.io import read_as_undirected_hyperedge_list
import numpy as np
import zipfile

from tqdm.contrib.concurrent import process_map
from collections import defaultdict
from scipy.linalg import norm as normf
from scipy.stats import pearsonr
from scipy.spatial.distance import cosine


if __name__ == '__main__':

    root = sys.argv[1]
    typ = sys.argv[2]
    data_path = folder + root
    print(root, typ)

    # READ ORIGINAL
    vmap = defaultdict(int)
    with open(f'{data_path}.tsv') as in_f:
        uedges = read_as_undirected_hyperedge_list(in_f, vmap)

    N = len(vmap)

    # LAPLACIAN
    max_d = max([len(h) for h in uedges])
    max_d = min(order, max_d)
    gamma = np.ones(max_d - 1)
    eivals, eivals_mul = compute_eigenvalues(edges=uedges,
                                             max_d=max_d,
                                             eig_num=eig_num,
                                             tol=toll,
                                             N=N,
                                             gamma=gamma,
                                             symmetric=symmetric)
    with open(met_path + f"multi_laplacian_{root}__sym_{symmetric}.tsv", 'w') as out_f:
        out_f.write('Order\tEig\n')
        for ev in eivals_mul:
            out_f.write(f'multi\t{ev}\n')
        for idx, eig_lst in enumerate(eivals):
            for e in eig_lst:
                out_f.write(f'{idx + 2}\t{e}\n')
    print('eigenvalues observed hypergraph computed.')

    file_path = f'{sample_path}/{typ}/{root}.zip'
    out_f = open(
        met_path + f"multi_laplacian_{root}__sym_{symmetric}_{typ}_samples.tsv", 'w')
    out_f.write('Sampler\tSample Id\tOrder\tEig\n')
    metric_path = met_path + \
        f"laplacian_metrics_{root}__sym_{symmetric}__{typ}.tsv"

    z = zipfile.ZipFile(file_path, "r")
    zinfo = z.namelist()
    inputs = []
    for file_name in zinfo:
        if file_name.startswith(".") or file_name.startswith("__MACOSX"):
            continue
        if not file_name.endswith('.tsv'):
            continue
        inputs.append([file_path, file_name, vmap, max_d, N, gamma, toll,
                       eig_num, symmetric, typ])
    outputs = process_map(parallel_laplacian, inputs, max_workers=max_workers)

    for out in outputs:
        algo = out[0]
        sid = out[1]
        eigs = out[2]
        eigsm = out[3]
        for ev in eigsm:
            out_f.write(f'{algo}\t{sid}\tmulti\t{ev}\n')
        for idx, eig_lst in enumerate(eigs):
            for e in eig_lst:
                out_f.write(f'{algo}\t{sid}\t{idx + 2}\t{e}\n')
    out_f.close()
    print('eigenvalues computed.')

    # COMPUTE METRICS
    lines = []
    for out in outputs:
        algo = out[0]
        sid = out[1]
        eigs = out[2]
        eigsm = out[3]
        # multiorder
        sp_dist_m = normf(eivals_mul - eigsm, ord=2) / len(eivals_mul)
        cos_m = cosine(eivals_mul, eigsm)
        pear_m = pearsonr(eivals_mul, eigsm)[0]
        lines.append(f'{algo}\t{sid}\tmulti\t{sp_dist_m}\t{cos_m}\t{pear_m}\n')
        # for each order d
        for idx, eig_lst in enumerate(eigs):
            sp_dist = None
            cos = None
            pear = None
            if np.sum(eivals[idx]) > 0 and np.sum(eig_lst) > 0:
                sp_dist = normf(eivals[idx] - eig_lst, ord=2) / len(eig_lst)
                cos = cosine(eivals[idx], eig_lst)
                pear = pearsonr(eivals[idx], eig_lst)[0]
            lines.append(
                f'{algo}\t{sid}\t{idx + 2}\t{sp_dist}\t{cos}\t{pear}\n')
    with open(metric_path, 'w') as out_f:
        out_f.write(
            'Sampler\tSample Id\tOrder\tSpectral Distance\tCosine Distance\tPearson\n')
        for line in lines:
            out_f.write(line)
    print('spectral distances computed.')
